#pragma once
#include <external.hpp>
#include <vkargsetter.hpp>

/*
#ifndef VK_UUID_SIZE
#define VK_UUID_SIZE 16U
#endif
*/

namespace vkargsetter {

/** VkPhysicalDeviceProperties

  \code{.cpp}
typedef struct VkPhysicalDeviceProperties {

uint32_t apiVersion;

uint32_t driverVersion;

uint32_t vendorID;

uint32_t deviceID;

VkPhysicalDeviceType deviceType;

char deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];

uint8_t pipelineCacheUUID[VK_UUID_SIZE];

VkPhysicalDeviceLimits limits;

VkPhysicalDeviceSparseProperties sparseProperties;
} VkPhysicalDeviceProperties;
  \endcode

- apiVersion is the version of Vulkan supported by the
device, encoded as described in Version
Numbers.
- driverVersion is the vendor-specified version of the
driver.
- vendorID is a unique identifier for the vendor (see below)
of the physical device.
- deviceID is a unique identifier for the physical device
among devices available from the vendor.
- deviceType is a VkPhysicalDeviceType specifying the type
of device.
- deviceName is an array of VK_MAX_PHYSICAL_DEVICE_NAME_SIZE
char containing a null-terminated
UTF-8 string which is the name of the device.
- pipelineCacheUUID is an array of VK_UUID_SIZE uint8_t
values representing a universally unique
identifier for the device.
- limits is the VkPhysicalDeviceLimits structure specifying
device-specific limits of the physical
device. See Limits for details.
- sparseProperties is the VkPhysicalDeviceSparseProperties
structure specifying various sparse
related properties of the physical device. See Sparse
Properties for details.
 */

constexpr void setVkArg(VkPhysicalDeviceProperties2 &prop) {
  prop.sType =
      VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
}

void setVkArg(VkPhysicalDeviceProperties2 &prop,
              const VkPhysicalDeviceProperties &p) {
  prop.properties = p;
}

/** VkPhysicalDeviceVulkan11Properties

  \code{.cpp}
typedef struct VkPhysicalDeviceVulkan11Properties {

VkStructureType sType;

void* pNext;

uint8_t deviceUUID[VK_UUID_SIZE];

uint8_t driverUUID[VK_UUID_SIZE];

uint8_t deviceLUID[VK_LUID_SIZE];

uint32_t deviceNodeMask;

VkBool32 deviceLUIDValid;

uint32_t subgroupSize;

VkShaderStageFlags subgroupSupportedStages;

VkSubgroupFeatureFlags subgroupSupportedOperations;

VkBool32 subgroupQuadOperationsInAllStages;

VkPointClippingBehavior pointClippingBehavior;

uint32_t maxMultiviewViewCount;

uint32_t maxMultiviewInstanceIndex;

VkBool32 protectedNoFault;

uint32_t maxPerSetDescriptors;

VkDeviceSize maxMemoryAllocationSize;
} VkPhysicalDeviceVulkan11Properties;
\endcode

- sType is the type of this structure.
- pNext is NULL or a pointer to a structure extending this
structure.
- deviceUUID is an array of VK_UUID_SIZE uint8_t values
representing a universally unique
identifier for the device.
- driverUUID is an array of VK_UUID_SIZE uint8_t values
representing a universally unique
identifier for the driver build in use by the device.
- deviceLUID is an array of VK_LUID_SIZE uint8_t values
representing a locally unique identifier for
the device.
- deviceNodeMask is a uint32_t bitfield identifying the node
within a linked device adapter
corresponding to the device.
- deviceLUIDValid is a boolean value that will be VK_TRUE if
deviceLUID contains a valid LUID and
deviceNodeMask contains a valid node mask, and VK_FALSE if
they do not.
- subgroupSize is the default number of invocations in each
subgroup. subgroupSize is at least 1 if
any of the physical device’s queues support
VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT.
subgroupSize is a power-of-two.
- subgroupSupportedStages is a bitfield of
VkShaderStageFlagBits describing the shader stages that
group operations with subgroup scope are supported in.
subgroupSupportedStages will have the
VK_SHADER_STAGE_COMPUTE_BIT bit set if any of the physical
device’s queues support
VK_QUEUE_COMPUTE_BIT.
- subgroupSupportedOperations is a bitmask of
VkSubgroupFeatureFlagBits specifying the sets of
group operations with subgroup scope supported on this
device. subgroupSupportedOperations
will have the VK_SUBGROUP_FEATURE_BASIC_BIT bit set if any
of the physical device’s queues
support VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT.
- subgroupQuadOperationsInAllStages is a boolean specifying
whether quad group operations are
available in all stages, or are restricted to fragment and
compute stages.
- pointClippingBehavior is a VkPointClippingBehavior value
specifying the point clipping
behavior supported by the implementation.
- maxMultiviewViewCount is one greater than the maximum view
index that can be used in a
subpass.
- maxMultiviewInstanceIndex is the maximum valid value of
instance index allowed to be
generated by a drawing command recorded within a subpass of
a multiview render pass
instance.
- protectedNoFault specifies the behavior of the
implementation when protected memory access
rules are broken. If protectedNoFault is VK_TRUE, breaking
those rules will not result in process
termination or device loss.
- maxPerSetDescriptors is a maximum number of descriptors
(summed over all descriptor types)
in a single descriptor set that is guaranteed to satisfy any
implementation-dependent
constraints on the size of a descriptor set itself.
Applications can query whether a descriptor set
that goes beyond this limit is supported using
vkGetDescriptorSetLayoutSupport.
- maxMemoryAllocationSize is the maximum size of a memory
allocation that can be created, even
if there is more space available in the heap.
 */
constexpr void
setVkArg(VkPhysicalDeviceVulkan11Properties &prop) {
  prop.sType =
      VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES;
}

void setVkArg(VkPhysicalDeviceVulkan11Properties &prop,
              std::uint8_t device_uuid[VK_UUID_SIZE],
              std::uint8_t driver_uuid[VK_UUID_SIZE],
              std::uint8_t device_luid[VK_LUID_SIZE]) {
  //
  for (std::uint8_t i = 0; i < VK_UUID_SIZE; i++) {
    prop.deviceUUID[i] = device_uuid[i];
    prop.driverUUID[i] = driver_uuid[i];
  }
  for (std::uint8_t i = 0; i < VK_LUID_SIZE; i++) {
    prop.deviceLUID[i] = device_luid[i];
  }
}

void setVkArg(
    VkPhysicalDeviceVulkan11Properties &prop,
    const std::uint32_t &device_node_mask,
    const std::uint32_t &subgroup_size,
    const std::uint32_t &max_multiview_viewcount,
    const std::uint32_t &max_multiview_instance_index,
    const std::uint32_t &max_perset_descriptors) {
  //
  prop.deviceNodeMask = device_node_mask;
  prop.subgroupSize = subgroup_size;
  prop.maxMultiviewViewCount = max_multiview_viewcount;
  prop.maxMultiviewInstanceIndex =
      max_multiview_instance_index;
  prop.maxPerSetDescriptors = max_perset_descriptors;
}
void setVkArg(VkPhysicalDeviceVulkan11Properties &prop,
              void *pNext) {
  prop.pNext = pNext;
}

void setVkArg(
    VkPhysicalDeviceVulkan11Properties &prop,
    const VkBool32 &device_luid_valid,
    const VkBool32 &subgroup_quad_operations_in_all_stages,
    const VkBool32 &protected_no_fault) {
  prop.deviceLUIDValid = device_luid_valid;
  prop.subgroupQuadOperationsInAllStages =
      subgroup_quad_operations_in_all_stages;
  prop.protectedNoFault = protected_no_fault;
}

template <std::size_t N>
struct setVkArray<VkPhysicalDeviceVulkan11Properties, N,
                  VkShaderStageFlagBits,
                  VkSubgroupFeatureFlagBits> {
  static void
  set(VkPhysicalDeviceVulkan11Properties &prop,
      const std::array<VkShaderStageFlagBits, N> &sflags,
      const std::array<VkSubgroupFeatureFlagBits, N>
          &fflags) {
    VkShaderStageFlags sf = sflags[0];
    VkSubgroupFeatureFlags ff = fflags[0];
    for (std::size_t i = 1; i < N; i++) {
      sf |= sflags[i];
      ff |= fflags[i];
    }
    prop.subgroupSupportedStages = sf;
    prop.subgroupSupportedOperations = ff;
  }
};

template <>
struct setVkVector<VkPhysicalDeviceVulkan11Properties,
                   VkShaderStageFlagBits,
                   VkSubgroupFeatureFlagBits> {
  static void
  set(VkPhysicalDeviceVulkan11Properties &prop,
      const std::vector<VkShaderStageFlagBits> &sflags,
      const std::vector<VkSubgroupFeatureFlagBits>
          &fflags) {
    VkShaderStageFlags sf = sflags[0];
    VkSubgroupFeatureFlags ff = fflags[0];
    for (std::size_t i = 1; i < sflags.size(); i++) {
      sf |= sflags[i];
    }
    for (std::size_t i = 1; i < sflags.size(); i++) {
      sf |= sflags[i];
    }
    prop.subgroupSupportedStages = sf;
    prop.subgroupSupportedOperations = ff;
  }
};

void setVkArg(
    VkPhysicalDeviceVulkan11Properties &prop,
    const VkShaderStageFlags &subgroup_supported_stages,
    const VkSubgroupFeatureFlags
        &subgroup_supported_operations) {
  prop.subgroupSupportedStages = subgroup_supported_stages;
  prop.subgroupSupportedOperations =
      subgroup_supported_operations;
}

template <std::size_t N>
struct setVkArray<VkPhysicalDeviceVulkan11Properties, N,
                  VkShaderStageFlagBits> {
  static void
  set(VkPhysicalDeviceVulkan11Properties &prop,
      const std::array<VkShaderStageFlagBits, N> &sflags) {
    VkShaderStageFlags sf = sflags[0];
    for (std::size_t i = 1; i < N; i++) {
      sf |= sflags[i];
    }
    prop.subgroupSupportedStages = sf;
  }
};

template <std::size_t N>
struct setVkArray<VkPhysicalDeviceVulkan11Properties, N,
                  VkSubgroupFeatureFlagBits> {
  static void
  set(VkPhysicalDeviceVulkan11Properties &prop,
      const std::array<VkSubgroupFeatureFlagBits, N> &fflags) {
    VkSubgroupFeatureFlags sf = fflags[0];
    for (std::size_t i = 1; i < N; i++) {
      sf |= fflags[i];
    }
    prop.subgroupSupportedOperations = sf;
  }
};

void setVkArg(
    VkPhysicalDeviceVulkan11Properties &prop,
    const VkDeviceSize &max_memory_allocation_size) {
  prop.maxMemoryAllocationSize = max_memory_allocation_size;
}
}
